#!/usr/bin/env zsh
#
# weaver.sh — Build a dependency tree (Markdown) of the crates that are
# fetched from the Polkadot-SDK git repository.
#
# The script looks at the *workspace* that this script is executed inside.
# It finds every crate whose *source* points to the URL below and then figures
# out which of those crates depend on each other.  Finally it emits a simple
# Markdown document where each crate is an item and its direct SDK-git
# dependencies are sub-items.
#
# Usage:
#   ./sdk-upgrader/tools/weaver.sh [OUTPUT_FILE]
#
# If OUTPUT_FILE is omitted, a file called
#   polkadot_sdk_dependency_tree.md
# will be created/overwritten in the current working directory.
#
# Requirements:
#   • zsh or bash >= 4 (this script uses associative arrays)
#   • cargo ≥ 1.68  (built-in `cargo metadata` command)
#   • jq           (for JSON processing)
#
set -euo pipefail

# ------------------------------ helpers ------------------------------------
err() { echo "\e[31merror:\e[0m $*" >&2; exit 1; }

command -v jq    >/dev/null 2>&1 || err "jq not found – please install jq"
command -v cargo >/dev/null 2>&1 || err "cargo not found – Rust toolchain missing?"

# ------------------------------ config -------------------------------------
SDK_GIT_URL="https://github.com/paritytech/polkadot-sdk"
OUTPUT_FILE="${1:-polkadot_sdk_dependency_tree.md}"

# Create temporary files for mappings
ID_TO_NAME_FILE=$(mktemp)
DEPENDS_FILE=$(mktemp)
SDK_IDS_FILE=$(mktemp)

# Cleanup function
cleanup() {
  rm -f "$ID_TO_NAME_FILE" "$DEPENDS_FILE" "$SDK_IDS_FILE"
}
trap cleanup EXIT

# --------------------------- gather metadata ------------------------------
# We need full dependency resolution because we want cross-crate relationships
# inside the SDK git crates.
metadata_json=$(cargo metadata --format-version 1 --all-features)

# Collect the *package ids* of every crate that is pulled from the SDK repo.
# Handle both https://github.com/paritytech/polkadot-sdk.git and https://github.com/paritytech/polkadot-sdk
printf '%s\n' "$metadata_json" | \
  jq -r --arg url "$SDK_GIT_URL" '.packages[] | select(.source and (.source | contains($url))) | .id' > "$SDK_IDS_FILE"

if [[ ! -s "$SDK_IDS_FILE" ]]; then
  err "No crates sourced from $SDK_GIT_URL found in workspace"
fi

# Build a map from package-id → crate-name for pretty printing.
while read -r id; do
  name=$(printf '%s\n' "$metadata_json" | jq -r --arg ID "$id" '.packages[] | select(.id == $ID) | .name')
  if [[ -n "$name" && "$name" != "null" ]]; then
    printf '%s\t%s\n' "$id" "$name" >> "$ID_TO_NAME_FILE"
  fi
done < "$SDK_IDS_FILE"

# ----------------------- figure out inter-dependencies ---------------------
# Create a map  sdk_id → (space-separated list of sdk_id deps)

while read -r id; do
  # Get dependencies for this package from the resolve section
  deps_filtered=""
  
  # Use jq to directly filter SDK dependencies
  deps=$(printf '%s\n' "$metadata_json" | jq -r --arg ID "$id" --arg URL "$SDK_GIT_URL" '
    .resolve.nodes[] | 
    select(.id == $ID) | 
    .dependencies[]? | 
    select(. | contains($URL))
  ')
  
  while read -r dep_id; do
    [[ -z "$dep_id" ]] && continue
    # Trim any whitespace from dep_id
    dep_id=$(echo "$dep_id" | xargs)
    deps_filtered+="$dep_id "
  done <<< "$deps"
  
  printf '%s\t%s\n' "$id" "${deps_filtered%% }" >> "$DEPENDS_FILE"
done < "$SDK_IDS_FILE"

# ------------------------------ output -------------------------------------
(
  echo "# Polkadot SDK (git) dependency tree"
  echo ""
  echo "Generated by \`sdk-upgrader/tools/weaver.sh\` on $(date -u '+%Y-%m-%d %H:%M:%S %Z')."
  echo ""
  echo "Found $(wc -l < "$SDK_IDS_FILE") crates sourced from the Polkadot SDK git repository."
  echo ""
  
  # Process each crate directly
  while read -r id; do
    # Get crate name using awk
    name=$(awk -F'\t' -v id="$id" '$1 == id {print $2}' "$ID_TO_NAME_FILE")
    if [[ -n "$name" ]]; then
      echo "- **$name**"
      
      # Get the full dependencies line
      deps_data=$(awk -F'\t' -v id="$id" '$1 == id {print $0}' "$DEPENDS_FILE")
      
      if [[ -n "$deps_data" ]]; then
        # Extract just the dependencies part (after the tab)
        deps_part=$(echo "$deps_data" | cut -f2-)
        
        if [[ -n "$deps_part" ]] && [[ "$deps_part" != "$id" ]]; then
          # Collect dependency names
          dep_names=()
          
          # Split on spaces to get individual dependency IDs
          echo "$deps_part" | tr ' ' '\n' | while read -r dep_id; do
            [[ -z "$dep_id" ]] && continue
            dep_name=$(awk -F'\t' -v id="$dep_id" '$1 == id {print $2}' "$ID_TO_NAME_FILE")
            if [[ -n "$dep_name" ]]; then
              echo "$dep_name"
            fi
          done | sort -u | while read -r dep_name; do
            echo "  - $dep_name"
          done | grep . || echo "  - *(no SDK dependencies)*"
        else
          echo "  - *(no SDK dependencies)*"
        fi
      else
        echo "  - *(no SDK dependencies)*"
      fi
    fi
  done < "$SDK_IDS_FILE"
) > "$OUTPUT_FILE"

echo "Dependency tree written to $OUTPUT_FILE"
